---
// @ts-nocheck
---

<div class="cosmic-background">
  <canvas class="galaxy-canvas"></canvas>
  <div class="nebula-glow"></div>
  <div class="galaxy-dust"></div>
  <div class="star-clusters"></div>
  <div class="custom-cursor"></div>
</div>

<style>
  .cosmic-background {
    position: fixed;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    width: 100vw;
    height: 100vh;
    z-index: -1;
    overflow: hidden;
    background: radial-gradient(ellipse at center, 
      hsl(260, 80%, 7%) 0%, 
      hsl(240, 90%, 5%) 50%, 
      hsl(220, 100%, 2%) 100%
    );
  }

  .galaxy-canvas {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    opacity: 1;
    z-index: 10; /* Higher z-index but below content */
    cursor: none; /* Hide cursor for more immersive experience */
    pointer-events: all; /* Ensure mouse events are captured */
  }
  
  .custom-cursor {
    position: fixed;
    width: 30px;
    height: 30px;
    border-radius: 50%;
    border: 2px solid rgba(255, 255, 255, 0.6);
    background: radial-gradient(circle at center, rgba(255, 255, 255, 0.4) 0%, rgba(100, 200, 255, 0.2) 50%, transparent 100%);
    pointer-events: none;
    transform: translate(-50%, -50%);
    z-index: 19;
    box-shadow: 0 0 10px rgba(100, 200, 255, 0.5);
    transition: width 0.2s, height 0.2s, opacity 0.2s;
    opacity: 0;
    mix-blend-mode: screen;
    filter: blur(1px);
  }

  .nebula-glow {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: 
      radial-gradient(ellipse at 35% 35%, rgba(88, 58, 208, 0.15) 0%, transparent 60%),
      radial-gradient(ellipse at 65% 65%, rgba(72, 149, 239, 0.15) 0%, transparent 60%),
      radial-gradient(ellipse at 45% 25%, rgba(177, 87, 247, 0.1) 0%, transparent 60%),
      radial-gradient(ellipse at 25% 75%, rgba(55, 218, 214, 0.1) 0%, transparent 60%),
      radial-gradient(ellipse at 50% 50%, rgba(255, 255, 255, 0.05) 0%, transparent 100%);
    filter: blur(20px);
    animation: nebula-pulse 25s infinite alternate;
    mix-blend-mode: screen;
    z-index: 2;
  }

  .galaxy-dust {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: 
      url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='400' height='400' viewBox='0 0 800 800'%3E%3Cg fill='none' stroke='%23FFFFFF' stroke-width='1'%3E%3Cpath d='M769 229L1037 260.9M927 880L731 737 520 660 309 538 40 599 295 764 126.5 879.5 40 599-197 493 102 382-31 229 126.5 79.5-69-63'/%3E%3Cpath d='M-31 229L237 261 390 382 603 493 308.5 537.5 101.5 381.5M370 905L295 764'/%3E%3Cpath d='M520 660L578 842 731 737 840 599 603 493 520 660 295 764 309 538 390 382 539 269 769 229 577.5 41.5 370 105 295 -36 126.5 79.5 237 261 102 382 40 599 -69 737 127 880'/%3E%3Cpath d='M520-140L578.5 42.5 731-63M603 493L539 269 237 261 370 105M902 382L539 269M390 382L102 382'/%3E%3Cpath d='M-222 42L126.5 79.5 370 105 539 269 577.5 41.5 927 80 769 229 902 382 603 493 731 737M295-36L577.5 41.5M578 842L295 764M40-201L127 80M102 382L-261 269'/%3E%3C/g%3E%3Cg fill='%23FFFFFF'%3E%3Ccircle cx='769' cy='229' r='1'/%3E%3Ccircle cx='539' cy='269' r='1'/%3E%3Ccircle cx='603' cy='493' r='1'/%3E%3Ccircle cx='731' cy='737' r='1'/%3E%3Ccircle cx='520' cy='660' r='1'/%3E%3Ccircle cx='309' cy='538' r='1'/%3E%3Ccircle cx='295' cy='764' r='1'/%3E%3Ccircle cx='40' cy='599' r='1'/%3E%3Ccircle cx='102' cy='382' r='1'/%3E%3Ccircle cx='127' cy='80' r='1'/%3E%3Ccircle cx='370' cy='105' r='1'/%3E%3Ccircle cx='578' cy='42' r='1'/%3E%3Ccircle cx='237' cy='261' r='1'/%3E%3Ccircle cx='390' cy='382' r='1'/%3E%3C/g%3E%3C/svg%3E");
    background-size: 150% 150%;
    opacity: 0.05;
    animation: dust-drift 120s linear infinite;
    z-index: 3;
  }

  .star-clusters {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    z-index: 4;
    opacity: 0.6;
  }

  .star-clusters::before {
    content: "";
    position: absolute;
    width: 100%;
    height: 100%;
    background: 
      radial-gradient(1px 1px at 10% 10%, rgba(255, 255, 255, 1) 1%, transparent 2%),
      radial-gradient(1.5px 1.5px at 20% 50%, rgba(255, 255, 255, 0.8) 1%, transparent 2%),
      radial-gradient(1px 1px at 30% 30%, rgba(173, 216, 230, 0.8) 1%, transparent 2%),
      radial-gradient(2px 2px at 40% 70%, rgba(255, 255, 255, 0.9) 1%, transparent 2%),
      radial-gradient(1.5px 1.5px at 50% 20%, rgba(240, 248, 255, 0.8) 1%, transparent 2%),
      radial-gradient(1px 1px at 60% 60%, rgba(176, 196, 222, 0.8) 1%, transparent 2%),
      radial-gradient(2px 2px at 70% 40%, rgba(255, 255, 255, 0.9) 1%, transparent 2%),
      radial-gradient(1.5px 1.5px at 80% 90%, rgba(135, 206, 250, 0.8) 1%, transparent 2%),
      radial-gradient(1px 1px at 90% 10%, rgba(255, 255, 255, 0.7) 1%, transparent 2%);
    background-size: 500% 500%;
    animation: stars-twinkle 8s infinite alternate, stars-move 150s linear infinite;
  }

  .star-clusters::after {
    content: "";
    position: absolute;
    width: 100%;
    height: 100%;
    background: 
      radial-gradient(2px 2px at 15% 15%, rgba(255, 255, 255, 0.9) 1%, transparent 2%),
      radial-gradient(1px 1px at 25% 25%, rgba(176, 224, 230, 0.7) 1%, transparent 2%),
      radial-gradient(1.5px 1.5px at 35% 35%, rgba(255, 255, 255, 0.8) 1%, transparent 2%),
      radial-gradient(1px 1px at 45% 45%, rgba(173, 216, 230, 0.7) 1%, transparent 2%),
      radial-gradient(2px 2px at 55% 55%, rgba(255, 255, 255, 0.9) 1%, transparent 2%),
      radial-gradient(1.5px 1.5px at 65% 65%, rgba(240, 248, 255, 0.8) 1%, transparent 2%),
      radial-gradient(1px 1px at 75% 75%, rgba(176, 196, 222, 0.7) 1%, transparent 2%),
      radial-gradient(2px 2px at 85% 85%, rgba(255, 255, 255, 0.9) 1%, transparent 2%),
      radial-gradient(1.5px 1.5px at 95% 95%, rgba(135, 206, 250, 0.8) 1%, transparent 2%);
    background-size: 300% 300%;
    transform: rotate(30deg);
    animation: stars-twinkle 10s infinite alternate-reverse, stars-move 200s linear infinite reverse;
  }

  @keyframes nebula-pulse {
    0% {
      opacity: 0.1;
      filter: blur(15px);
    }
    50% {
      opacity: 0.15;
      filter: blur(20px);
    }
    100% {
      opacity: 0.1;
      filter: blur(15px);
    }
  }

  @keyframes dust-drift {
    0% {
      background-position: 0% 0%;
      opacity: 0.05;
    }
    50% {
      opacity: 0.08;
    }
    100% {
      background-position: 100% 100%;
      opacity: 0.05;
    }
  }

  @keyframes stars-twinkle {
    0% {
      opacity: 0.4;
    }
    50% {
      opacity: 0.7;
    }
    100% {
      opacity: 0.6;
    }
  }

  @keyframes stars-move {
    0% {
      background-position: 0% 0%;
    }
    100% {
      background-position: 100% 100%;
    }
  }

  @keyframes spin {
    0% {
      transform: rotate(0deg);
    }
    100% {
      transform: rotate(360deg);
    }
  }

  @keyframes orbit {
    0% {
      transform: rotate(0deg) translateX(var(--orbit-distance)) rotate(0deg);
    }
    100% {
      transform: rotate(360deg) translateX(var(--orbit-distance)) rotate(-360deg);
    }
  }

  @media (prefers-reduced-motion: reduce) {
    .nebula-glow, .galaxy-dust, .star-clusters, .galaxy-canvas {
      animation: none !important;
      transition: none !important;
    }
    .star-clusters::before, .star-clusters::after {
      animation: none !important;
    }
    .galaxy-canvas {
      display: none !important;
    }
  }

  /* Dark mode adjustments */
  :root[data-theme="dark"] .cosmic-background {
    opacity: 1;
  }

  /* Light mode adjustments */
  :root[data-theme="light"] .cosmic-background {
    opacity: 0.7;
    background: radial-gradient(ellipse at center, 
      hsl(260, 50%, 15%) 0%, 
      hsl(240, 60%, 10%) 50%, 
      hsl(220, 70%, 5%) 100%
    );
  }

  :root[data-theme="light"] .nebula-glow {
    opacity: 0.1;
    mix-blend-mode: multiply;
  }

  :root[data-theme="light"] .galaxy-dust {
    opacity: 0.03;
  }
  
  :root[data-theme="light"] .star-clusters {
    opacity: 0.4;
  }
</style>

<script>
  /* 
   * @ts-nocheck
   */
  // Define star particle type
  interface Star {
    x: number;
    y: number;
    r: number;
    theta: number;
    armOffset: number;
    orbitalSpeed: number;
    isCoreStar: boolean;
    color: string;
    size: number;
    brightness: number;
    twinkleSpeed: number;
    twinklePhase: number;
    currentBrightness?: number;
    originalX: number;
    originalY: number;
    velocityX: number;
    velocityY: number;
    mass: number;
    interactStrength: number;
  }

  // Define dust particle type
  interface DustParticle {
    x: number;
    y: number;
    r: number;
    theta: number;
    color: string;
    size: number;
    orbitalSpeed: number;
    originalX: number;
    originalY: number;
    velocityX: number;
    velocityY: number;
    mass: number;
    interactStrength: number;
  }

  // Define explosion particle type
  interface ExplosionParticle {
    x: number;
    y: number;
    vx: number;
    vy: number;
    size: number;
    color: string;
    life: number;
    maxLife: number;
  }

  // Define cursor update tracking
  interface CursorUpdate {
    time: number;
    x: number;
    y: number;
  }

  // Class for creating the dynamic galaxy animation
  class GalaxyAnimation {
    // Canvas properties
    private canvas: HTMLCanvasElement;
    private ctx: CanvasRenderingContext2D;
    
    // State arrays
    private stars: Star[] = [];
    private dustParticles: DustParticle[] = [];
    private explosionParticles: ExplosionParticle[] = []; // For click explosion effect
    
    // Positioning
    private centerX: number = 0;
    private centerY: number = 0;
    private canvasWidth: number = 0;
    private canvasHeight: number = 0;
    private galaxyRadius: number = 0;
    
    // Animation properties
    private rotation: number = 0;
    private rotationSpeed: number = 0.0001;
    private spiral: number = 0;
    private spiralDirection: number = 1;
    private spiralSpeed: number = 0.00005;
    private isDarkTheme: boolean;
    private arms: number = 5; // Number of spiral arms
    private armWidth: number = 0.4; // Width of the spiral arms
    
    // Mouse interaction properties
    private mouseX: number = -1000; // Off-screen by default
    private mouseY: number = -1000;
    private mouseActive: boolean = false;
    private mouseRadius: number = 150; // Mouse influence radius
    private mouseForce: number = 1.0; // Strength of repulsion
    private gravityStrength: number = 0.04; // How strongly particles are pulled back
    private clickForce: number = 3.0; // Strength of click explosion
    private lastCursorUpdate: CursorUpdate | null = null;
    
    // Touch properties
    private touchStartX: number | undefined;
    private touchStartY: number | undefined;

    constructor(canvas: HTMLCanvasElement) {
      this.canvas = canvas;
      this.ctx = canvas.getContext('2d') as CanvasRenderingContext2D;
      this.isDarkTheme = document.documentElement.getAttribute('data-theme') === 'dark';

      this.updateCanvasSize();
      this.generateStars();
      this.generateDust();
      this.animate();
    }

    updateCanvasSize() {
      this.canvas.width = window.innerWidth;
      this.canvas.height = window.innerHeight;
      this.canvasWidth = this.canvas.width;
      this.canvasHeight = this.canvas.height;
      this.centerX = this.canvasWidth / 2;
      this.centerY = this.canvasHeight / 2;
      this.galaxyRadius = Math.min(this.canvasWidth, this.canvasHeight) * 0.4;
    }

    generateStars() {
      // Adaptive star count - slightly fewer stars for cleaner appearance
      const starCount = Math.min(1800, Math.max(500, Math.floor(this.canvasWidth * this.canvasHeight / 2500)));
      this.stars = [];

      // Generate stars with different properties
      for (let i = 0; i < starCount; i++) {
        // Decide whether this star is a regular star or a core star
        const isCoreStar = Math.random() < 0.12; // 12% of stars are in the core
        
        // Calculate distance from center (r) with a different distribution for core stars
        let r;
        let theta;
        let armOffset;
        
        if (isCoreStar) {
          // Core stars have a small radius and are more concentrated in the center
          r = Math.random() * this.galaxyRadius * 0.2;
          theta = Math.random() * Math.PI * 2; // Random angle
          armOffset = 0; // No arm offset for core stars
        } else {
          // Regular stars follow a modified distribution to form arms
          r = Math.random() * Math.random() * this.galaxyRadius; // Quadratic falloff gives more stars in center
          theta = Math.random() * Math.PI * 2; // Random initial angle
          
          // Calculate which arm this star belongs to
          const armIndex = Math.floor(Math.random() * this.arms);
          const armAngle = (Math.PI * 2 / this.arms) * armIndex;
          
          // Modify angle to create spiral arms with some randomness
          const spiralFactor = 0.5; // How tightly the spiral winds
          const angleOffset = spiralFactor * Math.log(r / this.galaxyRadius + 0.1);
          theta = armAngle + angleOffset;
          
          // Add some random offset from the perfect spiral - tighter clustering for better definition
          armOffset = (Math.random() - 0.5) * this.armWidth * 0.8;
        }
        
        // Calculate initial position
        const x = r * Math.cos(theta + armOffset);
        const y = r * Math.sin(theta + armOffset);
        
        // Star properties - adjusted color ranges for better clarity
        const starType = Math.random();
        let color;
        let size;
        
        if (starType < 0.6) { // Most stars are white/blue-ish
          const hue = Math.random() * 40 + 190; // 190-230: blue to cyan
          const saturation = Math.random() * 25 + 75; // 75-100%
          const lightness = Math.random() * 20 + 75; // 75-95% - brighter stars overall
          color = `hsla(${hue}, ${saturation}%, ${lightness}%, 1)`;
          size = Math.random() * 1.3 + 0.5; // Slightly smaller for less blur
        } else if (starType < 0.8) { // Some are yellow
          const hue = Math.random() * 25 + 45; // 45-70: yellow
          const saturation = Math.random() * 30 + 70;
          const lightness = Math.random() * 20 + 75;
          color = `hsla(${hue}, ${saturation}%, ${lightness}%, 0.95)`;
          size = Math.random() * 1.5 + 0.7;
        } else if (starType < 0.95) { // Few are red
          const hue = Math.random() * 20 + 350; // 350-370: red
          const saturation = Math.random() * 25 + 75;
          const lightness = Math.random() * 20 + 75;
          color = `hsla(${hue}, ${saturation}%, ${lightness}%, 0.9)`;
          size = Math.random() * 1.7 + 0.9;
        } else { // Very few are special bright stars
          color = `hsla(0, 0%, 100%, 1)`;
          // Slightly smaller special stars for dark mode clarity
          size = Math.random() * 2.2 + 1.3;
        }
        
        // Orbital properties - slightly faster rotation overall
        const orbitalSpeed = isCoreStar 
          ? (0.006 + Math.random() * 0.005) * (Math.random() < 0.5 ? 1 : -1) // Core stars have varied speeds and directions
          : (0.0012 + Math.random() * 0.0018) / (r / this.galaxyRadius + 0.1); // Outer stars move slower
        
        // Add star to array with properties for interactive movement
        this.stars.push({
          x, y, r, theta, armOffset, 
          orbitalSpeed,
          isCoreStar,
          color,
          size,
          brightness: Math.random() * 0.4 + 0.6, // Higher brightness base for better visibility
          twinkleSpeed: Math.random() * 0.02 + 0.01, // Slightly less twinkling for less blurry look
          twinklePhase: Math.random() * Math.PI * 2,
          // Properties for mouse interaction
          originalX: x,
          originalY: y,
          velocityX: 0,
          velocityY: 0,
          mass: size * (isCoreStar ? 2 : 1), // Bigger stars have more mass
          interactStrength: Math.random() * 0.4 + 0.8 // Some stars react more than others
        });
      }
    }

    generateDust() {
      // Reduced dust count for better performance and clarity
      const dustCount = Math.floor(this.canvasWidth * this.canvasHeight / 15000);
      this.dustParticles = [];
      
      for (let i = 0; i < dustCount; i++) {
        const r = Math.random() * Math.random() * this.galaxyRadius * 1.2;
        const theta = Math.random() * Math.PI * 2;
        
        // Dust follows the spiral structure too but with more variation
        const armIndex = Math.floor(Math.random() * this.arms);
        const armAngle = (Math.PI * 2 / this.arms) * armIndex;
        const spiralFactor = 0.3;
        const angleOffset = spiralFactor * Math.log(r / this.galaxyRadius + 0.1);
        const actualTheta = armAngle + angleOffset + (Math.random() - 0.5) * this.armWidth * 2;
        
        const x = r * Math.cos(actualTheta);
        const y = r * Math.sin(actualTheta);
        
        // Crisper, more refined colors for dust
        let hue, saturation, lightness, opacity;
        
        if (Math.random() < 0.7) {
          // Blue to purple-ish (most dust)
          hue = Math.random() * 60 + 180; 
          saturation = Math.random() * 30 + 40;
          lightness = Math.random() * 15 + 65;
          opacity = Math.random() * 0.1 + 0.03;
        } else if (Math.random() < 0.9) {
          // Some slightly reddish dust
          hue = Math.random() * 30 + 350;
          saturation = Math.random() * 30 + 30;
          lightness = Math.random() * 15 + 65;
          opacity = Math.random() * 0.08 + 0.02;
        } else {
          // Very few bright dust particles
          hue = Math.random() * 360;
          saturation = Math.random() * 20 + 10;
          lightness = Math.random() * 20 + 75;
          opacity = Math.random() * 0.05 + 0.05;
        }
        
        this.dustParticles.push({
          x, y, r, theta: actualTheta,
          color: `hsla(${hue}, ${saturation}%, ${lightness}%, ${opacity})`,
          size: Math.random() * 2 + 0.5, // Smaller dust particles for better definition
          orbitalSpeed: (0.0005 + Math.random() * 0.001) / (r / this.galaxyRadius + 0.1),
          // Properties for mouse interaction
          originalX: x,
          originalY: y,
          velocityX: 0,
          velocityY: 0,
          mass: Math.random() * 0.5 + 0.2, // Dust has less mass than stars
          interactStrength: Math.random() * 0.7 + 0.9 // Dust is more affected by mouse
        });
      }
    }

    // Create more subtle celestial effect particles
    createCelestialEffect(x, y, particleCount = 20, direction = 0) {
      // Add subtle space-like particles
      for (let i = 0; i < particleCount; i++) {
        // Spiral pattern for celestial feel
        const spiralTightness = 0.2 + Math.random() * 0.3;
        const spiralAngle = i / particleCount * Math.PI * (4 + Math.random() * 2);
        const distanceFromCenter = 3 + Math.random() * 10 * (1 - i / particleCount);
        
        const angle = spiralAngle + Math.random() * 0.2 - 0.1;
        
        // Gentler speed for cosmic feel
        const baseSpeed = Math.random() * 2 + 0.8;
        const speed = baseSpeed * (1 - i / particleCount * 0.5); // Slower particles farther out
        
        // Calculate velocity components with some directional bias
        const directionBias = direction * 0.3; // Subtle direction based on scroll
        const vx = Math.cos(angle) * speed;
        const vy = Math.sin(angle) * speed + directionBias;
        
        // Small particles for star-like effect
        const size = Math.random() * 1.2 + 0.3;
        
        // Celestial color palette - predominantly blues and whites
        let hue, saturation, lightness, opacity;
        
        const colorType = Math.random();
        if (colorType < 0.6) { // Predominantly blue/white stars
          hue = Math.floor(Math.random() * 40) + 200; // 200-240: blue range
          saturation = Math.floor(Math.random() * 40) + 10; // 10-50%: less saturated
          lightness = Math.floor(Math.random() * 20) + 75; // 75-95%: bright stars
          opacity = Math.random() * 0.4 + 0.6; // 0.6-1.0: semi-transparent
        } else if (colorType < 0.9) { // Some subtle purples
          hue = Math.floor(Math.random() * 40) + 250; // 250-290: purple range
          saturation = Math.floor(Math.random() * 20) + 10; // 10-30%: very desaturated
          lightness = Math.floor(Math.random() * 15) + 75; // 75-90%: bright
          opacity = Math.random() * 0.3 + 0.6; // 0.6-0.9: more transparent
        } else { // Few faint red/yellow (distant stars or dust)
          hue = Math.floor(Math.random() * 60) + 10; // 10-70: red to yellow
          saturation = Math.floor(Math.random() * 20) + 20; // 20-40%: desaturated
          lightness = Math.floor(Math.random() * 15) + 75; // 75-90%: bright
          opacity = Math.random() * 0.3 + 0.3; // 0.3-0.6: quite transparent
        }
        
        // Longer lifespans for slower, gentler effect
        const baseLife = Math.random() * 80 + 60; // 60-140: longer lived
        const life = baseLife * (1 + Math.sin(i / particleCount * Math.PI) * 0.2);
        
        // Calculate position with spiral pattern
        const particleX = x + Math.cos(spiralAngle) * distanceFromCenter;
        const particleY = y + Math.sin(spiralAngle) * distanceFromCenter;
        
        this.explosionParticles.push({
          x: particleX,
          y: particleY,
          vx,
          vy,
          size,
          color: `hsla(${hue}, ${saturation}%, ${lightness}%, ${opacity})`,
          life,
          maxLife: life,
        });
      }
    }
    
    // Create explosion particles at position (used for click effects)
    createExplosion(x, y, particleCount = 30) {
      // Add variation based on direction and intensity
      for (let i = 0; i < particleCount; i++) {
        // Random direction with some variation
        const angle = Math.random() * Math.PI * 2;
        
        // Moderate speed for subtle effect
        const baseSpeed = Math.random() * 4 + 2;
        const speed = baseSpeed * (1 - i / particleCount * 0.3);
        
        // Calculate velocity components
        const vx = Math.cos(angle) * speed;
        const vy = Math.sin(angle) * speed;
        
        // Smaller particles for star-like effect
        const size = Math.random() * 1.8 + 0.4;
        
        // Celestial color palette - predominantly blues and purples
        let hue, saturation, lightness;
        
        if (i < particleCount * 0.7) {
          // Mostly blue/cyan particles for celestial feel
          hue = Math.floor(Math.random() * 40) + 190; // 190-230: blue to cyan
          saturation = Math.floor(Math.random() * 40) + 30; // 30-70%
          lightness = Math.floor(Math.random() * 15) + 80; // 80-95%: bright
        } else {
          // Some subtle purple/violet particles
          hue = Math.floor(Math.random() * 40) + 250; // 250-290: purple range
          saturation = Math.floor(Math.random() * 30) + 20; // 20-50%
          lightness = Math.floor(Math.random() * 15) + 75; // 75-90%
        }
        
        // Varied lifespans for natural fading
        const baseLife = Math.random() * 50 + 30; // 30-80
        const life = baseLife * (1 - i / particleCount * 0.2);
        
        this.explosionParticles.push({
          x,
          y,
          vx,
          vy,
          size,
          color: `hsla(${hue}, ${saturation}%, ${lightness}%, 0.9)`,
          life,
          maxLife: life,
        });
      }
    }
    
    updateStars() {
      // Update the spiral factor
      this.spiral += this.spiralSpeed * this.spiralDirection;
      if (this.spiral > 0.2 || this.spiral < -0.2) {
        this.spiralDirection *= -1;
      }
      
      // Update explosion particles
      for (let i = 0; i < this.explosionParticles.length; i++) {
        const particle = this.explosionParticles[i];
        
        // Update position
        particle.x += particle.vx;
        particle.y += particle.vy;
        
        // Apply gravity and friction
        particle.vx *= 0.96;
        particle.vy *= 0.96;
        particle.vy += 0.1; // Slight gravity downward
        
        // Decrease life
        particle.life -= 1;
        
        // Remove dead particles
        if (particle.life <= 0) {
          this.explosionParticles.splice(i, 1);
          i--; // Adjust index after removal
        }
      }
      
      // Update the rotation
      this.rotation += this.rotationSpeed;
      
      // Update each star with mouse interaction
      for (let i = 0; i < this.stars.length; i++) {
        const star = this.stars[i];
        
        // Store the orbital position as the natural position
        // Update position based on orbital motion
        star.theta += star.orbitalSpeed;
        
        // Apply spiral effect (more pronounced for outer stars)
        const spiralEffect = star.isCoreStar ? 0 : this.spiral * (star.r / this.galaxyRadius);
        const adjustedTheta = star.theta + spiralEffect;
        
        // Calculate natural orbital position
        star.originalX = star.r * Math.cos(adjustedTheta + star.armOffset);
        star.originalY = star.r * Math.sin(adjustedTheta + star.armOffset);
        
        // Apply mouse interaction physics
        if (this.mouseActive) {
          // Calculate distance from mouse
          const dx = (this.centerX + star.x) - this.mouseX;
          const dy = (this.centerY + star.y) - this.mouseY;
          const distanceSquared = dx * dx + dy * dy;
          const distance = Math.sqrt(distanceSquared);
          
          // If within influence radius, apply repulsion force
          if (distance < this.mouseRadius) {
            // Calculate repulsion force (stronger when closer)
            const force = (1 - distance / this.mouseRadius) * this.mouseForce * star.interactStrength;
            
            // Apply force to velocity (normalized direction * force / mass)
            star.velocityX += (dx / distance) * force / star.mass;
            star.velocityY += (dy / distance) * force / star.mass;
          }
        }
        
        // Apply gravity back to original position
        const dx = star.originalX - star.x;
        const dy = star.originalY - star.y;
        star.velocityX += dx * this.gravityStrength;
        star.velocityY += dy * this.gravityStrength;
        
        // Apply friction to dampen velocity
        star.velocityX *= 0.95;
        star.velocityY *= 0.95;
        
        // Update position based on velocity
        star.x += star.velocityX;
        star.y += star.velocityY;
        
        // Update twinkle effect
        star.twinklePhase += star.twinkleSpeed;
        star.currentBrightness = star.brightness * (0.7 + 0.3 * Math.sin(star.twinklePhase));
      }
      
      // Update dust particles with mouse interaction
      for (let i = 0; i < this.dustParticles.length; i++) {
        const dust = this.dustParticles[i];
        
        // Update orbital position
        dust.theta += dust.orbitalSpeed;
        dust.originalX = dust.r * Math.cos(dust.theta);
        dust.originalY = dust.r * Math.sin(dust.theta);
        
        // Apply mouse interaction physics - dust is more affected
        if (this.mouseActive) {
          // Calculate distance from mouse
          const dx = (this.centerX + dust.x) - this.mouseX;
          const dy = (this.centerY + dust.y) - this.mouseY;
          const distanceSquared = dx * dx + dy * dy;
          const distance = Math.sqrt(distanceSquared);
          
          // If within influence radius, apply repulsion force (larger radius for dust)
          if (distance < this.mouseRadius * 1.5) {
            // Calculate repulsion force (stronger when closer)
            const force = (1 - distance / (this.mouseRadius * 1.5)) * this.mouseForce * 1.5 * dust.interactStrength;
            
            // Apply force to velocity (normalized direction * force / mass)
            dust.velocityX += (dx / distance) * force / dust.mass;
            dust.velocityY += (dy / distance) * force / dust.mass;
          }
        }
        
        // Apply gravity back to original position (weaker for dust to make it float longer)
        const dx = dust.originalX - dust.x;
        const dy = dust.originalY - dust.y;
        dust.velocityX += dx * this.gravityStrength * 0.7;
        dust.velocityY += dy * this.gravityStrength * 0.7;
        
        // Apply friction to dampen velocity (less for dust so it floats longer)
        dust.velocityX *= 0.98;
        dust.velocityY *= 0.98;
        
        // Update position based on velocity
        dust.x += dust.velocityX;
        dust.y += dust.velocityY;
      }
    }

    drawGalaxy() {
      const ctx = this.ctx;
      
      // Clear canvas with full transparency
      ctx.clearRect(0, 0, this.canvasWidth, this.canvasHeight);
      
      // Draw center glow - more defined and less blurry for dark mode
      const gradient = ctx.createRadialGradient(
        this.centerX, this.centerY, 0,
        this.centerX, this.centerY, this.galaxyRadius * 0.25
      );
      
      if (this.isDarkTheme) {
        gradient.addColorStop(0, 'rgba(255, 255, 255, 0.15)');
        gradient.addColorStop(0.2, 'rgba(180, 200, 255, 0.08)');
        gradient.addColorStop(0.5, 'rgba(80, 100, 255, 0.05)');
        gradient.addColorStop(1, 'rgba(0, 0, 0, 0)');
      } else {
        gradient.addColorStop(0, 'rgba(255, 255, 255, 0.08)');
        gradient.addColorStop(0.3, 'rgba(180, 180, 255, 0.04)');
        gradient.addColorStop(0.6, 'rgba(255, 255, 255, 0.02)');
        gradient.addColorStop(1, 'rgba(0, 0, 0, 0)');
      }
      
      ctx.fillStyle = gradient;
      ctx.beginPath();
      ctx.arc(this.centerX, this.centerY, this.galaxyRadius * 0.4, 0, Math.PI * 2);
      ctx.fill();
      
      // Draw explosion particles (on top of everything for dramatic effect)
      for (let i = 0; i < this.explosionParticles.length; i++) {
        const particle = this.explosionParticles[i];
        
        // Calculate opacity based on remaining life
        const opacity = particle.life / particle.maxLife;
        
        // Draw particle with glow
        const glow = ctx.createRadialGradient(
          this.centerX + particle.x,
          this.centerY + particle.y,
          0,
          this.centerX + particle.x,
          this.centerY + particle.y,
          particle.size * 3
        );
        
        glow.addColorStop(0, particle.color.replace('1)', `${opacity})`));
        glow.addColorStop(1, particle.color.replace('1)', '0)'));
        
        ctx.fillStyle = glow;
        ctx.beginPath();
        ctx.arc(
          this.centerX + particle.x,
          this.centerY + particle.y,
          particle.size * 3,
          0,
          Math.PI * 2
        );
        ctx.fill();
        
        // Particle core
        ctx.fillStyle = particle.color.replace('1)', `${opacity})`);
        ctx.beginPath();
        ctx.arc(
          this.centerX + particle.x,
          this.centerY + particle.y,
          particle.size,
          0,
          Math.PI * 2
        );
        ctx.fill();
      }
      
      // Draw dust particles behind stars
      for (let i = 0; i < this.dustParticles.length; i++) {
        const dust = this.dustParticles[i];
        
        ctx.fillStyle = dust.color;
        ctx.beginPath();
        ctx.arc(
          this.centerX + dust.x, 
          this.centerY + dust.y, 
          dust.size, 
          0, 
          Math.PI * 2
        );
        ctx.fill();
      }
      
      // Draw stars
      for (let i = 0; i < this.stars.length; i++) {
        const star = this.stars[i];
        
        // Skip stars that would be outside the visible area
        if (
          this.centerX + star.x < -20 || 
          this.centerX + star.x > this.canvasWidth + 20 ||
          this.centerY + star.y < -20 || 
          this.centerY + star.y > this.canvasHeight + 20
        ) {
          continue;
        }
        
        // Draw star with adjusted rendering for clarity in dark mode
        const starOpacity = this.isDarkTheme ? star.currentBrightness : star.currentBrightness * 0.8;
        const glowSize = this.isDarkTheme ? 2 : 3; // Smaller glow in dark mode for less blur
        
        // Create more defined stars in dark mode
        if (this.isDarkTheme) {
          // Core glow
          const glow = ctx.createRadialGradient(
            this.centerX + star.x, 
            this.centerY + star.y, 
            0,
            this.centerX + star.x, 
            this.centerY + star.y, 
            star.size * glowSize
          );
          
          // Crisper gradient with harder edge
          glow.addColorStop(0, star.color.replace('1)', `${starOpacity})`));
          glow.addColorStop(0.7, star.color.replace('1)', `${starOpacity * 0.3})`));
          glow.addColorStop(1, star.color.replace('1)', '0)'));
          
          ctx.fillStyle = glow;
          ctx.beginPath();
          ctx.arc(
            this.centerX + star.x, 
            this.centerY + star.y, 
            star.size * glowSize, 
            0, 
            Math.PI * 2
          );
          ctx.fill();
          
          // Draw star center with sharper edge
          ctx.fillStyle = star.color.replace('1)', `${starOpacity * 1.2})`); // Brighter center
          ctx.beginPath();
          ctx.arc(
            this.centerX + star.x, 
            this.centerY + star.y, 
            star.size * 0.7, // Slightly smaller core for sharp appearance
            0, 
            Math.PI * 2
          );
          ctx.fill();
        } else {
          // Light mode - softer stars
          const glow = ctx.createRadialGradient(
            this.centerX + star.x, 
            this.centerY + star.y, 
            0,
            this.centerX + star.x, 
            this.centerY + star.y, 
            star.size * glowSize
          );
          
          glow.addColorStop(0, star.color.replace('1)', `${starOpacity})`));
          glow.addColorStop(1, star.color.replace('1)', '0)'));
          
          ctx.fillStyle = glow;
          ctx.beginPath();
          ctx.arc(
            this.centerX + star.x, 
            this.centerY + star.y, 
            star.size * glowSize, 
            0, 
            Math.PI * 2
          );
          ctx.fill();
          
          // Draw star center
          ctx.fillStyle = star.color.replace('1)', `${starOpacity})`);
          ctx.beginPath();
          ctx.arc(
            this.centerX + star.x, 
            this.centerY + star.y, 
            star.size, 
            0, 
            Math.PI * 2
          );
          ctx.fill();
        }
        
        // Add lens flare for brighter stars - adjusted for dark mode
        if ((this.isDarkTheme && star.size > 1.8) || (!this.isDarkTheme && star.size > 2)) {
          const flareOpacity = this.isDarkTheme ? starOpacity * 0.5 : starOpacity * 0.3;
          const flareLength = this.isDarkTheme ? star.size * 4 : star.size * 5;
          const flareWidth = this.isDarkTheme ? 0.4 : 0.5;
          
          ctx.strokeStyle = `rgba(255, 255, 255, ${flareOpacity})`;
          ctx.lineWidth = flareWidth;
          
          // Horizontal flare
          ctx.beginPath();
          ctx.moveTo(this.centerX + star.x - flareLength, this.centerY + star.y);
          ctx.lineTo(this.centerX + star.x + flareLength, this.centerY + star.y);
          ctx.stroke();
          
          // Vertical flare
          ctx.beginPath();
          ctx.moveTo(this.centerX + star.x, this.centerY + star.y - flareLength);
          ctx.lineTo(this.centerX + star.x, this.centerY + star.y + flareLength);
          ctx.stroke();
        }
      }
    }

    animate() {
      this.updateStars();
      this.drawGalaxy();
      requestAnimationFrame(this.animate.bind(this));
    }

    handleResize() {
      this.updateCanvasSize();
      // Regenerate with new dimensions
      this.generateStars();
      this.generateDust();
    }

    updateTheme(isDark) {
      this.isDarkTheme = isDark;
    }
    
    // Handle mouse movement
    handleMouseMove(event) {
      const rect = this.canvas.getBoundingClientRect();
      this.mouseX = event.clientX - rect.left;
      this.mouseY = event.clientY - rect.top;
      this.mouseActive = true;
      
      // Update custom cursor
      this.updateCustomCursor(event.clientX, event.clientY);
    }
    
    // Handle mouse enter
    handleMouseEnter() {
      // Show custom cursor
      const cursor = document.querySelector('.custom-cursor');
      if (cursor) {
        cursor.style.opacity = '1';
      }
    }
    
    // Handle mouse leave
    handleMouseLeave() {
      this.mouseActive = false;
      
      // Hide custom cursor
      const cursor = document.querySelector('.custom-cursor');
      if (cursor) {
        cursor.style.opacity = '0';
      }
    }
    
    // Update custom cursor position and appearance
    updateCustomCursor(x, y) {
      const cursor = document.querySelector('.custom-cursor');
      if (cursor) {
        cursor.style.left = `${x}px`;
        cursor.style.top = `${y}px`;
        
        // Make cursor bigger when moving fast (velocity effect)
        const now = Date.now();
        if (!this.lastCursorUpdate) {
          this.lastCursorUpdate = { time: now, x, y };
        } else {
          const dt = now - this.lastCursorUpdate.time;
          if (dt > 0) {
            const dx = x - this.lastCursorUpdate.x;
            const dy = y - this.lastCursorUpdate.y;
            const speed = Math.sqrt(dx*dx + dy*dy) / dt * 20;
            
            // Scale cursor based on speed
            const size = Math.min(50, Math.max(30, 30 + speed));
            cursor.style.width = `${size}px`;
            cursor.style.height = `${size}px`;
            
            // Update the last position and time
            this.lastCursorUpdate = { time: now, x, y };
          }
        }
      }
    }
    
    // Apply scroll-based distortion to stars and dust
    applyScrollExplosion(x, y, direction, scrollForce) {
      // Local coordinates relative to canvas
      const localX = x - this.centerX;
      const localY = y - this.centerY;
      
      // Create subtle celestial effect (fewer particles for celestial feel)
      const particleCount = Math.min(Math.floor(scrollForce * 6), 25);
      this.createCelestialEffect(localX, localY, particleCount, direction);
      
      // Calculate vertical force vector based on scroll direction with gentler bias
      // (for more subtle celestial movement rather than explosive)
      const verticalBias = direction * 1.2; // More gentle vertical influence for celestial feel
      
      // Apply gentler force to stars - more celestial flow than explosion
      for (let i = 0; i < this.stars.length; i++) {
        const star = this.stars[i];
        
        // Calculate distance from scroll center point
        const dx = star.x - localX;
        const dy = star.y - localY;
        const distanceSquared = dx * dx + dy * dy;
        const distance = Math.sqrt(distanceSquared);
        
        // Use wider influence radius for flowing effect
        // Scale the radius with scroll force for more gradual effect
        const influenceRadius = this.mouseRadius * (3 + scrollForce * 0.3);
        
        // If within influence radius, apply flowing force
        if (distance < influenceRadius) {
          // Calculate force with smoother falloff for celestial patterns
          // Use sine curve for more natural falloff
          const angle = (1 - distance / influenceRadius) * Math.PI;
          const distanceFactor = Math.sin(angle) * 0.8;
          const force = distanceFactor * this.clickForce * scrollForce * 0.7 * star.interactStrength;
          
          // Calculate swirl effect for more cosmic motion
          const swirlFactor = 0.6;
          const swirlAngle = Math.atan2(dy, dx) + (Math.PI / 2) * direction * swirlFactor;
          
          // Apply directional force with swirl component
          const normalizedDx = Math.cos(swirlAngle) + dx / (distance * 5 || 1); 
          const normalizedDy = Math.sin(swirlAngle) + (dy / (distance * 5 || 1) + verticalBias);
          
          // Apply gentler force to velocity
          star.velocityX += normalizedDx * force / star.mass * 0.8;
          star.velocityY += normalizedDy * force / star.mass * 1.2;
        }
      }
      
      // Apply similar effect to dust particles but with different pattern
      for (let i = 0; i < this.dustParticles.length; i++) {
        const dust = this.dustParticles[i];
        
        // Calculate distance from scroll center point
        const dx = dust.x - localX;
        const dy = dust.y - localY;
        const distanceSquared = dx * dx + dy * dy;
        const distance = Math.sqrt(distanceSquared);
        
        // Even larger influence radius for dust - cosmic nebula feel
        const influenceRadius = this.mouseRadius * (5 + scrollForce * 0.4);
        
        // If within influence radius, apply gentle force
        if (distance < influenceRadius) {
          // Calculate force with gentler cosmic nebula effect
          const distanceFactor = 0.5 * (1 + Math.cos(Math.PI * distance / influenceRadius));
          const force = distanceFactor * this.clickForce * scrollForce * 1.8 * dust.interactStrength;
          
          // Calculate cosmic flow - dust moves in slightly different pattern than stars
          const flowAngle = Math.atan2(dy, dx) + (Math.PI / 3) * direction;
          
          // Apply directional force with flow component
          const normalizedDx = Math.cos(flowAngle) * 0.7 + dx / (distance * 8 || 1);
          const normalizedDy = Math.sin(flowAngle) * 0.7 + (dy / (distance * 8 || 1) + verticalBias * 0.8);
          
          // Apply gentle force to create flowing nebula effect
          dust.velocityX += normalizedDx * force / dust.mass * 0.8;
          dust.velocityY += normalizedDy * force / dust.mass * 1.4;
        }
      }
    }
    
    // Apply click explosion force to stars and dust
    applyClickExplosion(x, y) {
      // Local coordinates relative to canvas
      const localX = x - this.centerX;
      const localY = y - this.centerY;
      
      // Create visual explosion particles
      this.createExplosion(localX, localY);
      
      // Apply force to stars
      for (let i = 0; i < this.stars.length; i++) {
        const star = this.stars[i];
        
        // Calculate distance from click
        const dx = star.x - localX;
        const dy = star.y - localY;
        const distanceSquared = dx * dx + dy * dy;
        const distance = Math.sqrt(distanceSquared);
        
        // If within influence radius, apply explosion force (larger than mouse radius)
        if (distance < this.mouseRadius * 1.5) {
          // Calculate force (stronger when closer)
          const force = (1 - distance / (this.mouseRadius * 1.5)) * this.clickForce * star.interactStrength;
          
          // Apply force to velocity (normalized direction * force / mass)
          star.velocityX += (dx / distance) * force / star.mass;
          star.velocityY += (dy / distance) * force / star.mass;
        }
      }
      
      // Apply force to dust particles
      for (let i = 0; i < this.dustParticles.length; i++) {
        const dust = this.dustParticles[i];
        
        // Calculate distance from click
        const dx = dust.x - localX;
        const dy = dust.y - localY;
        const distanceSquared = dx * dx + dy * dy;
        const distance = Math.sqrt(distanceSquared);
        
        // If within influence radius, apply explosion force (larger for dust)
        if (distance < this.mouseRadius * 2) {
          // Calculate force (stronger when closer)
          const force = (1 - distance / (this.mouseRadius * 2)) * this.clickForce * 1.5 * dust.interactStrength;
          
          // Apply force to velocity (normalized direction * force / mass)
          dust.velocityX += (dx / distance) * force / dust.mass;
          dust.velocityY += (dy / distance) * force / dust.mass;
        }
      }
      
      // Make custom cursor larger briefly for click feedback
      const cursor = document.querySelector('.custom-cursor');
      if (cursor) {
        cursor.style.width = '60px';
        cursor.style.height = '60px';
        
        // Reset size after animation
        setTimeout(() => {
          cursor.style.width = '30px';
          cursor.style.height = '30px';
        }, 200);
      }
    }
    
    // Setup interaction events
    setupMouseInteraction() {
      // Track scroll position to create explosion effect
      let lastScrollY = window.scrollY;
      let lastScrollTime = Date.now();
      let scrollDirection = 0;
      let scrollVelocity = 0;
      let isScrolling = false;
      let scrollDetectionTimeout = null;
      let lastExplosionTime = 0;
      
      // Function to create cosmic flow at start of scrolling
      const createCelestialScrollEffect = () => {
        const viewportHeight = window.innerHeight;
        const viewportWidth = window.innerWidth;
        const rect = this.canvas.getBoundingClientRect();
        
        // Number of celestial flows based on viewport size
        const numFlows = Math.floor((viewportWidth / 500) * 2) + 1;
        
        // Create primary flow pattern at center
        const centerX = viewportWidth / 2 - rect.left;
        const centerY = viewportHeight / 2 - rect.top + (scrollDirection * viewportHeight * 0.1);
        
        // Apply primary celestial distortion (gentler force)
        this.applyScrollExplosion(centerX, centerY, scrollDirection, 5);
        
        // Create additional subtle flows in a gentle pattern
        for (let i = 0; i < numFlows; i++) {
          // Calculate positions in an arc pattern in the direction of scroll
          const arcSpread = Math.PI * 0.7; // 126 degrees arc
          const arcStart = -Math.PI * 0.35 + (scrollDirection < 0 ? Math.PI : 0); // Different arc based on direction
          const angle = arcStart + (i / numFlows) * arcSpread;
          
          // Position more flows in scroll direction for natural feel
          const distance = viewportHeight * (0.2 + Math.random() * 0.1);
          
          const xPos = centerX + Math.cos(angle) * distance;
          const yPos = centerY + Math.sin(angle) * distance;
          
          // Apply gentle celestial effects with varied timing
          setTimeout(() => {
            const force = 3 - (i * 0.4); // Gentler forces
            this.applyScrollExplosion(xPos, yPos, scrollDirection, force);
          }, i * 100 + Math.random() * 50);
        }
      };
      
      // Add scroll event listener with requestAnimationFrame to ensure smooth animation
      let animationFrameId = null;
      let isScrollAnimating = false;
      
      // Function to ensure animate() keeps running during scroll
      const ensureAnimationContinues = () => {
        if (animationFrameId) {
          cancelAnimationFrame(animationFrameId);
        }
        
        const animateScroll = () => {
          // Keep animation running for a bit after scrolling stops
          if (isScrolling) {
            animationFrameId = requestAnimationFrame(animateScroll);
          } else if (isScrollAnimating) {
            // Continue for a short while after scrolling stops
            animationFrameId = requestAnimationFrame(animateScroll);
            // Check if we should stop extra animation
            if (Date.now() - lastScrollTime > 800) {
              isScrollAnimating = false;
            }
          }
        };
        
        isScrollAnimating = true;
        animateScroll();
      };
      
      // Main scroll event listener
      window.addEventListener('scroll', () => {
        // Calculate time since last scroll
        const currentTime = Date.now();
        const timeDiff = currentTime - lastScrollTime;
        lastScrollTime = currentTime;
        
        // Determine scroll direction and distance
        const currentScrollY = window.scrollY;
        const scrollDiff = currentScrollY - lastScrollY;
        scrollDirection = scrollDiff > 0 ? 1 : -1;
        
        // Calculate scroll velocity (pixels per millisecond)
        scrollVelocity = Math.abs(scrollDiff) / (timeDiff || 1);
        
        // Make sure animation continues during scrolling
        ensureAnimationContinues();
        
        // Detect start of scrolling for main celestial effect
        if (!isScrolling && Math.abs(scrollDiff) > 20) {
          isScrolling = true;
          
          // Only trigger main effect if not too frequent
          if (currentTime - lastExplosionTime > 400) {
            // Trigger celestial flow at scroll start
            createCelestialScrollEffect();
            lastExplosionTime = currentTime;
          }
        }
        
        // Continue gentle celestial effects during scrolling
        if (isScrolling && Math.abs(scrollDiff) > 15) {
          // Add subtle continuous effects during scrolling (less frequent than before)
          if (currentTime - lastExplosionTime > 250) {
            const viewportHeight = window.innerHeight;
            const viewportWidth = window.innerWidth;
            const rect = this.canvas.getBoundingClientRect();
            
            // Create subtle distortion in the direction of scrolling
            const xVariance = (Math.random() * 0.5 - 0.25) * viewportWidth;
            const x = (viewportWidth / 2) + xVariance - rect.left;
            
            // Position slightly ahead in scroll direction
            const yOffset = scrollDirection * viewportHeight * 0.15;
            const y = (viewportHeight / 2) - rect.top + yOffset;
            
            // Gentler force for more celestial feel
            const force = Math.min(scrollVelocity * 6, 4);
            
            // Apply the celestial distortion effect
            this.applyScrollExplosion(x, y, scrollDirection, force);
            lastExplosionTime = currentTime;
          }
        }
        
        // Update last scroll position
        lastScrollY = currentScrollY;
        
        // Keep interaction active during scrolling
        this.mouseActive = true;
        
        // Clear existing timeout
        if (scrollDetectionTimeout) {
          clearTimeout(scrollDetectionTimeout);
        }
        
        // Detect when scrolling stops but keep animation going longer
        scrollDetectionTimeout = setTimeout(() => {
          isScrolling = false;
          // Don't immediately deactivate mouse interaction
          // Let the animation continue naturally
          setTimeout(() => {
            if (!isScrolling) {
              this.mouseActive = false;
            }
          }, 600);
        }, 300);
      }, { passive: true });
      
      // Keep click explosion for direct interaction
      this.canvas.addEventListener('click', (e) => {
        const rect = this.canvas.getBoundingClientRect();
        const x = e.clientX - rect.left;
        const y = e.clientY - rect.top;
        this.applyClickExplosion(x, y);
      });
      
      // Document mouse handling for cursor
      document.addEventListener('mousemove', (e) => {
        this.updateCustomCursor(e.clientX, e.clientY);
      });
      
      // Touch events
      this.canvas.addEventListener('touchend', (e) => {
        if (e.touches.length > 0) {
          const rect = this.canvas.getBoundingClientRect();
          const x = e.touches[0].clientX - rect.left;
          const y = e.touches[0].clientY - rect.top;
          this.applyClickExplosion(x, y);
        }
      });
    }
  }

  // Initialize and set up animation
  document.addEventListener('DOMContentLoaded', () => {
    const galaxyCanvas = document.querySelector('.galaxy-canvas') as HTMLCanvasElement | null;
    let galaxyAnimation: GalaxyAnimation | null = null;
    
    // Check for browser support and performance
    if (
      galaxyCanvas && 
      !navigator.userAgent.match(/firefox/i) && // Skip in Firefox due to performance issues
      window.matchMedia('(prefers-reduced-motion: no-preference)').matches // Check for reduced motion preference
    ) {
      galaxyAnimation = new GalaxyAnimation(galaxyCanvas);
      
      // Setup mouse interaction
      galaxyAnimation.setupMouseInteraction();
      
      // Handle window resize
      window.addEventListener('resize', () => {
        if (galaxyAnimation) {
          galaxyAnimation.handleResize();
        }
      });
      
      // Detect theme changes and update
      const observer = new MutationObserver((mutations) => {
        mutations.forEach((mutation) => {
          if (mutation.attributeName === 'data-theme' && galaxyAnimation) {
            const isDark = document.documentElement.getAttribute('data-theme') === 'dark';
            galaxyAnimation.updateTheme(isDark);
          }
        });
      });
      
      // Start observing the document root for theme attribute changes
      observer.observe(document.documentElement, {
        attributes: true,
        attributeFilter: ['data-theme']
      });
    }
  });
</script>