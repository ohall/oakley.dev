---
---

<div class="cosmic-background">
  <canvas class="galaxy-canvas"></canvas>
  <div class="nebula-glow"></div>
  <div class="galaxy-dust"></div>
  <div class="star-clusters"></div>
  <div class="custom-cursor">ðŸš€</div>
</div>

<style>
  .cosmic-background {
    position: fixed;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    width: 100%;
    height: 100%;
    z-index: -1;
    overflow: hidden;
    background: radial-gradient(ellipse at center, 
      hsl(260, 80%, 7%) 0%, 
      hsl(240, 90%, 5%) 50%, 
      hsl(220, 100%, 2%) 100%
    );
  }

  .galaxy-canvas {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    opacity: 1;
    z-index: 10; /* Higher z-index but below content */
    cursor: none; /* Hide cursor for more immersive experience */
    pointer-events: all; /* Ensure mouse events are captured */
  }
  
  .custom-cursor {
    position: fixed;
    font-size: 24px;
    pointer-events: none;
    transform: translate(-50%, -50%) rotate(0deg);
    z-index: 19;
    opacity: 0;
    text-shadow: 0 0 10px rgba(100, 200, 255, 0.8), 
                 0 0 20px rgba(120, 210, 255, 0.5);
    @media (min-width: 640px) {
      font-size: 32px;
      transition: transform 0.3s cubic-bezier(0.34, 1.56, 0.64, 1), opacity 0.2s, text-shadow 0.2s;
    }
    /* Slower transition for mobile */
    transition: transform 0.8s cubic-bezier(0.22, 1, 0.36, 1), opacity 0.3s, text-shadow 0.3s;
    will-change: transform, opacity, text-shadow, font-size;
    display: flex;
    align-items: center;
    justify-content: center;
  }

  .nebula-glow {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: 
      radial-gradient(ellipse at 35% 35%, rgba(88, 58, 208, 0.15) 0%, transparent 60%),
      radial-gradient(ellipse at 65% 65%, rgba(72, 149, 239, 0.15) 0%, transparent 60%),
      radial-gradient(ellipse at 45% 25%, rgba(177, 87, 247, 0.1) 0%, transparent 60%),
      radial-gradient(ellipse at 25% 75%, rgba(55, 218, 214, 0.1) 0%, transparent 60%),
      radial-gradient(ellipse at 50% 50%, rgba(255, 255, 255, 0.05) 0%, transparent 100%);
    filter: blur(20px);
    animation: nebula-pulse 25s infinite alternate;
    mix-blend-mode: screen;
    z-index: 2;
  }

  .galaxy-dust {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: 
      url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='400' height='400' viewBox='0 0 800 800'%3E%3Cg fill='none' stroke='%23FFFFFF' stroke-width='1'%3E%3Cpath d='M769 229L1037 260.9M927 880L731 737 520 660 309 538 40 599 295 764 126.5 879.5 40 599-197 493 102 382-31 229 126.5 79.5-69-63'/%3E%3Cpath d='M-31 229L237 261 390 382 603 493 308.5 537.5 101.5 381.5M370 905L295 764'/%3E%3Cpath d='M520 660L578 842 731 737 840 599 603 493 520 660 295 764 309 538 390 382 539 269 769 229 577.5 41.5 370 105 295 -36 126.5 79.5 237 261 102 382 40 599 -69 737 127 880'/%3E%3Cpath d='M520-140L578.5 42.5 731-63M603 493L539 269 237 261 370 105M902 382L539 269M390 382L102 382'/%3E%3Cpath d='M-222 42L126.5 79.5 370 105 539 269 577.5 41.5 927 80 769 229 902 382 603 493 731 737M295-36L577.5 41.5M578 842L295 764M40-201L127 80M102 382L-261 269'/%3E%3C/g%3E%3Cg fill='%23FFFFFF'%3E%3Ccircle cx='769' cy='229' r='1'/%3E%3Ccircle cx='539' cy='269' r='1'/%3E%3Ccircle cx='603' cy='493' r='1'/%3E%3Ccircle cx='731' cy='737' r='1'/%3E%3Ccircle cx='520' cy='660' r='1'/%3E%3Ccircle cx='309' cy='538' r='1'/%3E%3Ccircle cx='295' cy='764' r='1'/%3E%3Ccircle cx='40' cy='599' r='1'/%3E%3Ccircle cx='102' cy='382' r='1'/%3E%3Ccircle cx='127' cy='80' r='1'/%3E%3Ccircle cx='370' cy='105' r='1'/%3E%3Ccircle cx='578' cy='42' r='1'/%3E%3Ccircle cx='237' cy='261' r='1'/%3E%3Ccircle cx='390' cy='382' r='1'/%3E%3C/g%3E%3C/svg%3E");
    background-size: 150% 150%;
    opacity: 0.05;
    animation: dust-drift 120s linear infinite;
    z-index: 3;
  }

  .star-clusters {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    z-index: 4;
    opacity: 0.6;
  }

  .star-clusters::before {
    content: "";
    position: absolute;
    width: 100%;
    height: 100%;
    background: 
      radial-gradient(1px 1px at 10% 10%, rgba(255, 255, 255, 1) 1%, transparent 2%),
      radial-gradient(1.5px 1.5px at 20% 50%, rgba(255, 255, 255, 0.8) 1%, transparent 2%),
      radial-gradient(1px 1px at 30% 30%, rgba(173, 216, 230, 0.8) 1%, transparent 2%),
      radial-gradient(2px 2px at 40% 70%, rgba(255, 255, 255, 0.9) 1%, transparent 2%),
      radial-gradient(1.5px 1.5px at 50% 20%, rgba(240, 248, 255, 0.8) 1%, transparent 2%),
      radial-gradient(1px 1px at 60% 60%, rgba(176, 196, 222, 0.8) 1%, transparent 2%),
      radial-gradient(2px 2px at 70% 40%, rgba(255, 255, 255, 0.9) 1%, transparent 2%),
      radial-gradient(1.5px 1.5px at 80% 90%, rgba(135, 206, 250, 0.8) 1%, transparent 2%),
      radial-gradient(1px 1px at 90% 10%, rgba(255, 255, 255, 0.7) 1%, transparent 2%);
    background-size: 500% 500%;
    animation: stars-twinkle 8s infinite alternate, stars-move 150s linear infinite;
  }

  .star-clusters::after {
    content: "";
    position: absolute;
    width: 100%;
    height: 100%;
    background: 
      radial-gradient(2px 2px at 15% 15%, rgba(255, 255, 255, 0.9) 1%, transparent 2%),
      radial-gradient(1px 1px at 25% 25%, rgba(176, 224, 230, 0.7) 1%, transparent 2%),
      radial-gradient(1.5px 1.5px at 35% 35%, rgba(255, 255, 255, 0.8) 1%, transparent 2%),
      radial-gradient(1px 1px at 45% 45%, rgba(173, 216, 230, 0.7) 1%, transparent 2%),
      radial-gradient(2px 2px at 55% 55%, rgba(255, 255, 255, 0.9) 1%, transparent 2%),
      radial-gradient(1.5px 1.5px at 65% 65%, rgba(240, 248, 255, 0.8) 1%, transparent 2%),
      radial-gradient(1px 1px at 75% 75%, rgba(176, 196, 222, 0.7) 1%, transparent 2%),
      radial-gradient(2px 2px at 85% 85%, rgba(255, 255, 255, 0.9) 1%, transparent 2%),
      radial-gradient(1.5px 1.5px at 95% 95%, rgba(135, 206, 250, 0.8) 1%, transparent 2%);
    background-size: 300% 300%;
    transform: rotate(30deg);
    animation: stars-twinkle 10s infinite alternate-reverse, stars-move 200s linear infinite reverse;
  }

  @keyframes nebula-pulse {
    0% {
      opacity: 0.1;
      filter: blur(15px);
    }
    50% {
      opacity: 0.15;
      filter: blur(20px);
    }
    100% {
      opacity: 0.1;
      filter: blur(15px);
    }
  }

  @keyframes dust-drift {
    0% {
      background-position: 0% 0%;
      opacity: 0.05;
    }
    50% {
      opacity: 0.08;
    }
    100% {
      background-position: 100% 100%;
      opacity: 0.05;
    }
  }

  @keyframes stars-twinkle {
    0% {
      opacity: 0.4;
    }
    50% {
      opacity: 0.7;
    }
    100% {
      opacity: 0.6;
    }
  }

  @keyframes stars-move {
    0% {
      background-position: 0% 0%;
    }
    100% {
      background-position: 100% 100%;
    }
  }

  @keyframes spin {
    0% {
      transform: rotate(0deg);
    }
    100% {
      transform: rotate(360deg);
    }
  }

  @keyframes orbit {
    0% {
      transform: rotate(0deg) translateX(var(--orbit-distance)) rotate(0deg);
    }
    100% {
      transform: rotate(360deg) translateX(var(--orbit-distance)) rotate(-360deg);
    }
  }
  
  @keyframes rocket-thrust {
    0% {
      text-shadow: 0 0 10px rgba(100, 200, 255, 0.7),
                   0 0 20px rgba(120, 220, 255, 0.5);
      font-size: 32px;
    }
    50% {
      text-shadow: 0 0 20px rgba(120, 220, 255, 0.9),
                   0 0 30px rgba(140, 230, 255, 0.7),
                   0 0 40px rgba(160, 240, 255, 0.4);
      font-size: 35px;
    }
    100% {
      text-shadow: 0 0 10px rgba(100, 200, 255, 0.7),
                   0 0 20px rgba(120, 220, 255, 0.5);
      font-size: 32px;
    }
  }

  @media (prefers-reduced-motion: reduce) {
    .nebula-glow, .galaxy-dust, .star-clusters, .galaxy-canvas {
      animation: none !important;
      transition: none !important;
    }
    .star-clusters::before, .star-clusters::after {
      animation: none !important;
    }
    .galaxy-canvas {
      display: none !important;
    }
  }

  /* Dark mode adjustments */
  :root[data-theme="dark"] .cosmic-background {
    opacity: 1;
  }

  /* Light mode adjustments */
  :root[data-theme="light"] .cosmic-background {
    opacity: 0.7;
    background: radial-gradient(ellipse at center, 
      hsl(260, 50%, 15%) 0%, 
      hsl(240, 60%, 10%) 50%, 
      hsl(220, 70%, 5%) 100%
    );
  }

  :root[data-theme="light"] .nebula-glow {
    opacity: 0.1;
    mix-blend-mode: multiply;
  }

  :root[data-theme="light"] .galaxy-dust {
    opacity: 0.03;
  }
  
  :root[data-theme="light"] .star-clusters {
    opacity: 0.4;
  }
</style>

<script>
  document.addEventListener('DOMContentLoaded', function() {
    // Initialize galaxy animation
    const canvas = document.querySelector('.galaxy-canvas');
    const cursor = document.querySelector('.custom-cursor');
    
    if (!canvas) {
      // Canvas element not found, cannot initialize animation
      return;
    }
    
    // Skip animation in Firefox or if reduced motion is preferred
    if (navigator.userAgent.match(/firefox/i) || 
        window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
      // Animation disabled due to browser type or reduced motion preference
      canvas.style.display = 'none';
      return;
    }
    
    const ctx = canvas.getContext('2d');
    let width, height, centerX, centerY;
    let stars = [];
    let dust = [];
    let isDarkTheme = document.documentElement.getAttribute('data-theme') === 'dark';
    
    // Animation properties
    let rotationSpeed = 0.0003; // Base rotation speed
    let currentSpeed = rotationSpeed;
    
    // Initialize animation
    function init() {
      // Set canvas dimensions
      canvas.width = window.innerWidth;
      canvas.height = window.innerHeight;
      width = canvas.width;
      height = canvas.height;
      centerX = width / 2;
      centerY = height / 2;
      
      // Generate stars and dust
      createStars();
      createDust();
    }
    
    // Create stars with positions and properties
    function createStars() {
      // Reduce star count on mobile for better performance
      const isMobile = window.innerWidth < 640;
      const starCount = isMobile 
        ? Math.min(800, Math.floor(width * height / 4000))
        : Math.min(2000, Math.floor(width * height / 2200));
      stars = [];
      
      const galaxyRadius = Math.min(width, height) * 0.4;
      const galaxyArms = 4;
      
      for (let i = 0; i < starCount; i++) {
        // Determine star type and position
        const isCore = Math.random() < 0.1;
        const isPlane = Math.random() < 0.85;
        
        let r, theta, armOffset;
        let x, y;
        
        if (isCore) {
          // Core stars
          r = Math.random() * galaxyRadius * 0.15;
          theta = Math.random() * Math.PI * 2;
          armOffset = 0;
        } else if (isPlane) {
          // Stars in galactic plane/arms
          r = Math.pow(Math.random(), 1.3) * galaxyRadius;
          
          // Assign to a spiral arm
          const armIndex = Math.floor(Math.random() * galaxyArms);
          const baseArmAngle = (Math.PI * 2 / galaxyArms) * armIndex;
          
          // Calculate spiral angle
          const spiralTightness = 0.8;
          const spiralAngle = spiralTightness * Math.log(r / (galaxyRadius * 0.1));
          theta = baseArmAngle + spiralAngle;
          
          // Add some variance to arm position
          const armWidth = 0.3;
          const maxOffset = armWidth * (0.3 + 0.7 * r / galaxyRadius);
          armOffset = (Math.random() - 0.5) * maxOffset;
        } else {
          // Halo stars
          r = Math.random() * galaxyRadius * 1.2;
          theta = Math.random() * Math.PI * 2;
          armOffset = 0;
        }
        
        // Calculate initial position
        x = r * Math.cos(theta + armOffset);
        y = r * Math.sin(theta + armOffset);
        
        // Star colors
        let color;
        if (isCore) {
          // Core - yellower
          const hue = Math.random() * 40 + 40;
          const sat = Math.random() * 30 + 60;
          const light = Math.random() * 15 + 80;
          color = `hsla(${hue}, ${sat}%, ${light}%, 0.9)`;
        } else if (isPlane) {
          // Determine position in galaxy for color
          const distRatio = r / galaxyRadius;
          
          if (Math.abs(armOffset) < 0.1 && distRatio > 0.2) {
            // Arms - bluer stars
            const hue = Math.random() * 40 + 190;
            const sat = Math.random() * 30 + 70;
            const light = Math.random() * 15 + 75;
            color = `hsla(${hue}, ${sat}%, ${light}%, 0.9)`;
          } else {
            // Disk - mix of colors
            const hue = Math.random() < 0.7 ? 
                      (Math.random() * 40 + 190) : // blue-ish
                      (Math.random() * 60 + 30);   // yellow-ish
            const sat = Math.random() * 30 + 60;
            const light = Math.random() * 15 + 75;
            color = `hsla(${hue}, ${sat}%, ${light}%, 0.85)`;
          }
        } else {
          // Halo - redder older stars
          const hue = Math.random() * 30 + (Math.random() < 0.7 ? 350 : 30);
          const sat = Math.random() * 20 + 50;
          const light = Math.random() * 15 + 70;
          color = `hsla(${hue}, ${sat}%, ${light}%, 0.75)`;
        }
        
        // Assign orbital speed - follow realistic galactic rotation curve
        let orbitalSpeed;
        if (isCore) {
          orbitalSpeed = 0.006 + Math.random() * 0.003;
        } else if (isPlane) {
          const rRatio = r / (galaxyRadius * 0.2);
          orbitalSpeed = 0.006 * (1 - Math.exp(-rRatio)) / (1 + r / (galaxyRadius * 1.5));
          orbitalSpeed *= 0.8 + Math.random() * 0.4;
        } else {
          orbitalSpeed = (0.002 + Math.random() * 0.002) * (Math.random() < 0.5 ? 1 : -1);
        }
        
        // Add star
        stars.push({
          x: x,
          y: y,
          r: r,
          theta: theta,
          armOffset: armOffset,
          size: Math.random() * (isCore ? 1.6 : 1.2) + 0.5,
          color: color,
          orbitalSpeed: orbitalSpeed,
          originalX: x,
          originalY: y,
          vx: 0,
          vy: 0,
          isCore: isCore,
          isPlane: isPlane,
          brightness: Math.random() * 0.3 + 0.7,
          twinkleSpeed: Math.random() * 0.02 + 0.01,
          twinklePhase: Math.random() * Math.PI * 2
        });
      }
    }
    
    // Create dust particles
    function createDust() {
      // Reduce dust count on mobile for better performance
      const isMobile = window.innerWidth < 640;
      const dustCount = isMobile
        ? Math.floor(width * height / 20000)
        : Math.floor(width * height / 12000);
      dust = [];
      
      const galaxyRadius = Math.min(width, height) * 0.4;
      const galaxyArms = 4;
      
      for (let i = 0; i < dustCount; i++) {
        const isCore = Math.random() < 0.15;
        const isArm = Math.random() < 0.8;
        
        let r, theta;
        let x, y;
        
        if (isCore) {
          // Core dust
          r = Math.random() * galaxyRadius * 0.3;
          theta = Math.random() * Math.PI * 2;
        } else if (isArm) {
          // Arm dust - follows spiral pattern
          r = Math.pow(Math.random(), 0.8) * galaxyRadius * 1.1;
          
          // Assign to spiral arm
          const armIndex = Math.floor(Math.random() * galaxyArms);
          const baseArmAngle = (Math.PI * 2 / galaxyArms) * armIndex;
          
          const spiralTightness = 0.9;
          const spiralAngle = spiralTightness * Math.log(r / (galaxyRadius * 0.1));
          theta = baseArmAngle + spiralAngle;
          
          // Add small offset
          const armWidth = 0.4;
          const maxOffset = armWidth * (0.2 + 0.8 * r / galaxyRadius);
          theta += (Math.random() - 0.5) * maxOffset;
        } else {
          // Halo dust
          r = Math.random() * galaxyRadius * 1.3;
          theta = Math.random() * Math.PI * 2;
        }
        
        // Calculate position
        x = r * Math.cos(theta);
        y = r * Math.sin(theta);
        
        // Dust colors - more muted
        let color;
        let opacity = Math.random() * 0.05 + 0.02;
        
        if (isCore) {
          const hue = Math.random() * 30 + 40;
          const sat = Math.random() * 20 + 50;
          const light = Math.random() * 10 + 50;
          color = `hsla(${hue}, ${sat}%, ${light}%, ${opacity})`;
        } else if (isArm) {
          // Choose dust color type
          const dustType = Math.random();
          if (dustType < 0.5) {
            // Blue nebula
            const hue = Math.random() * 40 + 200;
            const sat = Math.random() * 30 + 30;
            const light = Math.random() * 10 + 60;
            color = `hsla(${hue}, ${sat}%, ${light}%, ${opacity})`;
          } else if (dustType < 0.8) {
            // Purplish
            const hue = Math.random() * 40 + 260;
            const sat = Math.random() * 30 + 20;
            const light = Math.random() * 10 + 55;
            color = `hsla(${hue}, ${sat}%, ${light}%, ${opacity})`;
          } else {
            // Reddish
            const hue = Math.random() * 30 + 350;
            const sat = Math.random() * 30 + 40;
            const light = Math.random() * 10 + 50;
            color = `hsla(${hue}, ${sat}%, ${light}%, ${opacity})`;
          }
        } else {
          // Halo dust - very faint
          const hue = Math.random() * 60 + 200;
          const sat = Math.random() * 20 + 10;
          const light = Math.random() * 15 + 60;
          color = `hsla(${hue}, ${sat}%, ${light}%, ${opacity*0.5})`;
        }
        
        // Calculate orbital speed
        let orbitalSpeed;
        if (isCore) {
          orbitalSpeed = 0.004 + Math.random() * 0.002;
        } else if (isArm) {
          const rRatio = r / (galaxyRadius * 0.2);
          orbitalSpeed = 0.005 * (1 - Math.exp(-rRatio)) / (1 + r / (galaxyRadius * 1.5));
          orbitalSpeed *= 0.85 + Math.random() * 0.3;
        } else {
          orbitalSpeed = (0.001 + Math.random() * 0.001) * (Math.random() < 0.5 ? 1 : -1);
        }
        
        dust.push({
          x: x,
          y: y,
          r: r,
          theta: theta,
          size: Math.random() * 1.8 + 0.4,
          color: color,
          orbitalSpeed: orbitalSpeed,
          originalX: x,
          originalY: y,
          vx: 0,
          vy: 0,
          isCore: isCore,
          isArm: isArm
        });
      }
    }
    
    // Update star positions and overall galaxy with enhanced effects for mouse interaction
    function updateStars() {
      // Handle special behavior when mouse just stopped
      if (mouseJustStopped) {
        applyGravitationalPull();
        mouseJustStopped = false;
      }
      
      // Initialize gravitational pull variable at the beginning of the function
      let gravitationalPull = 0.025; // Default value
      
      // Apply rotation and update positions
      for (let i = 0; i < stars.length; i++) {
        const star = stars[i];
        
        // Apply rotation based on current speed
        const scaledSpeed = star.isCore ? 
                          star.orbitalSpeed * (1 + (currentSpeed - rotationSpeed) * 1.5) : 
                          star.orbitalSpeed * (1 + (currentSpeed - rotationSpeed) * 3);
        
        star.theta += scaledSpeed;
        
        // Calculate orbital position
        const orbitalX = star.r * Math.cos(star.theta + star.armOffset);
        const orbitalY = star.r * Math.sin(star.theta + star.armOffset);
        
        // Calculate gravity back to orbit
        const dxToOrbit = orbitalX - star.x;
        const dyToOrbit = orbitalY - star.y;
        const distFromOrbit = Math.sqrt(dxToOrbit * dxToOrbit + dyToOrbit * dyToOrbit);
        
        // Apply mouse repulsion effect - stars fly away from cursor
        if (mouseActive && mouseX >= 0 && mouseY >= 0) {
          // Calculate distance between star and mouse cursor (in canvas coordinates)
          const dxToMouse = (star.x + centerX) - mouseX;
          const dyToMouse = (star.y + centerY) - mouseY;
          const distToMouse = Math.sqrt(dxToMouse * dxToMouse + dyToMouse * dyToMouse);
          
          // Define mouse influence radius
          const mouseInfluenceRadius = Math.min(width, height) * 0.2;
          
          // If star is within mouse influence radius, apply repulsion force
          if (distToMouse < mouseInfluenceRadius) {
            // Calculate repulsion strength based on distance (stronger when closer)
            const repulsionStrength = 0.5 * (1 - distToMouse / mouseInfluenceRadius);
            
            // Apply repulsion force
            const repulsionFactor = mouseMoving ? 1.5 : 0.8; // Stronger when mouse is moving
            
            // Calculate normalized direction vector from mouse to star
            const dirX = dxToMouse / (distToMouse || 1);
            const dirY = dyToMouse / (distToMouse || 1);
            
            // Apply repulsion force (push away from mouse)
            star.vx += dirX * repulsionStrength * repulsionFactor;
            star.vy += dirY * repulsionStrength * repulsionFactor;
            
            // Add some tangential component for swirling effect around cursor
            star.vx += dirY * repulsionStrength * 0.4;
            star.vy -= dirX * repulsionStrength * 0.4;
            
            // When mouse is active, increase the rotational speed for more dynamic effect
            currentSpeed = rotationSpeed * 3;
            
            // Reduce gravity when under mouse influence
            gravitationalPull = 0.005;
          }
        }
        
        // Calculate base gravitational force based on mouse movement
        if (mouseActive && mouseMoving) {
          // During active mouse movement: weak gravity to maximize flying outward
          gravitationalPull = 0.005 * (1 - Math.min(0.9, (currentSpeed - rotationSpeed) / rotationSpeed * 3));
        } else {
          // When mouse stops: stronger gravity for visible return effect
          gravitationalPull = 0.03 * (1 + Math.min(1, distFromOrbit / 100));
        }
        
        if (distFromOrbit > 0.1) {
          // Apply gravity based on orbital characteristics
          // Core stars are more strongly bound to their orbits
          const bindingFactor = star.isCore ? 1.2 : 0.7;
          star.vx += dxToOrbit * gravitationalPull * bindingFactor;
          star.vy += dyToOrbit * gravitationalPull * bindingFactor;
        }
        
        // Damping is different based on mouse movement
        // - Almost no damping during movement = particles fly far
        // - Stronger damping when stationary = smoother return
        const dampingFactor = mouseMoving ? 0.992 : 0.96;
        star.vx *= dampingFactor;
        star.vy *= dampingFactor;
        
        // Update position with higher velocity during mouse movement
        const velocityFactor = mouseMoving ? 1.25 : 1.0;
        star.x += star.vx * velocityFactor;
        star.y += star.vy * velocityFactor;
        
        // Update twinkle
        star.twinklePhase += star.twinkleSpeed;
        star.currentBrightness = star.brightness * (0.8 + 0.2 * Math.sin(star.twinklePhase));
      }
      
      // Update dust particles 
      updateDustParticles();
    }
    
    // Apply a strong gravitational pull when mouse stops
    function applyGravitationalPull() {
      // Apply gravitational pull when mouse stops
      
      // Apply to stars
      for (let i = 0; i < stars.length; i++) {
        const star = stars[i];
        
        // Calculate orbital position
        const orbitalX = star.r * Math.cos(star.theta + star.armOffset);
        const orbitalY = star.r * Math.sin(star.theta + star.armOffset);
        
        // Vector from current position to orbital position
        const dxToOrbit = orbitalX - star.x;
        const dyToOrbit = orbitalY - star.y;
        const distFromOrbit = Math.sqrt(dxToOrbit * dxToOrbit + dyToOrbit * dyToOrbit);
        
        // Apply a strong instantaneous pull toward orbit
        // Stronger for stars that are farther from their orbital position
        const pullFactor = Math.min(0.2, 0.05 + distFromOrbit / 100);
        
        // Add velocity toward orbit - core stars pulled more strongly
        star.vx += dxToOrbit * pullFactor * (star.isCore ? 1.2 : 0.8);
        star.vy += dyToOrbit * pullFactor * (star.isCore ? 1.2 : 0.8);
      }
      
      // Apply to dust with even stronger effect
      for (let i = 0; i < dust.length; i++) {
        const d = dust[i];
        
        // Calculate orbital position
        const orbitalX = d.r * Math.cos(d.theta);
        const orbitalY = d.r * Math.sin(d.theta);
        
        // Vector from current position to orbital position
        const dxToOrbit = orbitalX - d.x;
        const dyToOrbit = orbitalY - d.y;
        const distFromOrbit = Math.sqrt(dxToOrbit * dxToOrbit + dyToOrbit * dyToOrbit);
        
        // Apply a strong instantaneous pull toward orbit - stronger than stars
        // This creates a more dramatic "snap back" effect for dust
        const pullFactor = Math.min(0.3, 0.08 + distFromOrbit / 80);
        
        // Add velocity toward orbit
        d.vx += dxToOrbit * pullFactor;
        d.vy += dyToOrbit * pullFactor;
      }
    }
    
    function updateDustParticles() {
      // Update dust particles with mouse movement effects
      for (let i = 0; i < dust.length; i++) {
        const d = dust[i];
        
        // Apply rotation with greater effect for more dynamic visuals
        const scaledSpeed = d.isCore ? 
                          d.orbitalSpeed * (1 + (currentSpeed - rotationSpeed) * 2) : 
                          d.orbitalSpeed * (1 + (currentSpeed - rotationSpeed) * 4);
        
        d.theta += scaledSpeed;
        
        // Calculate orbital position
        const orbitalX = d.r * Math.cos(d.theta);
        const orbitalY = d.r * Math.sin(d.theta);
        
        // Apply mouse repulsion effect for dust particles - more dramatic than stars
        if (mouseActive && mouseX >= 0 && mouseY >= 0) {
          // Calculate distance between dust and mouse cursor (in canvas coordinates)
          const dxToMouse = (d.x + centerX) - mouseX;
          const dyToMouse = (d.y + centerY) - mouseY;
          const distToMouse = Math.sqrt(dxToMouse * dxToMouse + dyToMouse * dyToMouse);
          
          // Define mouse influence radius - larger for dust
          const mouseInfluenceRadius = Math.min(width, height) * 0.25;
          
          // If dust is within mouse influence radius, apply repulsion force
          if (distToMouse < mouseInfluenceRadius) {
            // Calculate repulsion strength based on distance (stronger when closer)
            const repulsionStrength = 0.8 * (1 - distToMouse / mouseInfluenceRadius);
            
            // Apply repulsion force - stronger for dust than stars
            const repulsionFactor = mouseMoving ? 1.8 : 1.0; // Even stronger when mouse is moving
            
            // Calculate normalized direction vector from mouse to dust
            const dirX = dxToMouse / (distToMouse || 1);
            const dirY = dyToMouse / (distToMouse || 1);
            
            // Apply repulsion force (push away from mouse)
            d.vx += dirX * repulsionStrength * repulsionFactor;
            d.vy += dirY * repulsionStrength * repulsionFactor;
            
            // Add stronger tangential component for swirling effect around cursor
            d.vx += dirY * repulsionStrength * 0.6;
            d.vy -= dirX * repulsionStrength * 0.6;
            
            // When mouse is active, increase rotation speed
            currentSpeed = rotationSpeed * 4;
          }
        }
        
        // Calculate gravity based on mouse state
        const dxToOrbit = orbitalX - d.x;
        const dyToOrbit = orbitalY - d.y;
        const distFromOrbit = Math.sqrt(dxToOrbit * dxToOrbit + dyToOrbit * dyToOrbit);
        
        // Calculate gravity with contrast between mouse moving/not moving
        let dustGravity;
        
        if (mouseActive && mouseMoving) {
          // During mouse movement: almost zero gravity to maximize streaming
          dustGravity = 0.003 * (1 - Math.min(0.95, (currentSpeed - rotationSpeed) / rotationSpeed * 4));
        } else {
          // When mouse stops: stronger gravity for visible return
          dustGravity = 0.02 * (1 + Math.min(1.2, distFromOrbit / 80));
        }
        
        if (distFromOrbit > 0.5) {
          // Apply gravity based on dust position
          const coreFactor = d.isCore ? 1 : 0.6; 
          d.vx += dxToOrbit * dustGravity * coreFactor;
          d.vy += dyToOrbit * dustGravity * coreFactor;
        }
        
        // Damping based on mouse movement
        const dustDampingFactor = mouseMoving ? 0.995 : 0.97;
        d.vx *= dustDampingFactor;
        d.vy *= dustDampingFactor;
        
        // Higher velocity during mouse movement for dramatic effect
        const velocityFactor = mouseMoving ? 1.5 : 1.0;
        d.x += d.vx * velocityFactor;
        d.y += d.vy * velocityFactor;
      }
      
      // Adjust rotation speed return rate based on mouse state
      const decayRate = mouseMoving ? 0.99 : 0.95;
      
      // Gradually return to normal rotation speed with smoother transition
      if (Math.abs(currentSpeed - rotationSpeed) > 0.0001) {
        currentSpeed = rotationSpeed + (currentSpeed - rotationSpeed) * decayRate;
      } else {
        currentSpeed = rotationSpeed;
      }
    }
    
    // Draw the galaxy
    function drawGalaxy() {
      // Clear canvas
      ctx.clearRect(0, 0, width, height);
      
      // Draw center glow
      const gradient = ctx.createRadialGradient(
        centerX, centerY, 0,
        centerX, centerY, Math.min(width, height) * 0.25
      );
      
      // Adjust glow based on theme
      if (isDarkTheme) {
        gradient.addColorStop(0, 'rgba(255, 255, 255, 0.15)');
        gradient.addColorStop(0.2, 'rgba(180, 200, 255, 0.08)');
        gradient.addColorStop(0.5, 'rgba(80, 100, 255, 0.05)');
        gradient.addColorStop(1, 'rgba(0, 0, 0, 0)');
      } else {
        gradient.addColorStop(0, 'rgba(255, 255, 255, 0.08)');
        gradient.addColorStop(0.3, 'rgba(180, 180, 255, 0.04)');
        gradient.addColorStop(0.6, 'rgba(255, 255, 255, 0.02)');
        gradient.addColorStop(1, 'rgba(0, 0, 0, 0)');
      }
      
      ctx.fillStyle = gradient;
      ctx.beginPath();
      ctx.arc(centerX, centerY, Math.min(width, height) * 0.4, 0, Math.PI * 2);
      ctx.fill();
      
      // Draw dust particles
      for (let i = 0; i < dust.length; i++) {
        const d = dust[i];
        
        ctx.fillStyle = d.color;
        ctx.beginPath();
        ctx.arc(
          centerX + d.x, 
          centerY + d.y, 
          d.size, 
          0, 
          Math.PI * 2
        );
        ctx.fill();
      }
      
      // Draw stars
      for (let i = 0; i < stars.length; i++) {
        const star = stars[i];
        
        // Skip stars outside the visible area
        if (
          centerX + star.x < -20 || 
          centerX + star.x > width + 20 ||
          centerY + star.y < -20 || 
          centerY + star.y > height + 20
        ) {
          continue;
        }
        
        // Calculate brightness
        const starOpacity = (star.currentBrightness || star.brightness) * (isDarkTheme ? 1 : 0.8);
        
        // Draw star
        const glow = ctx.createRadialGradient(
          centerX + star.x, 
          centerY + star.y, 
          0,
          centerX + star.x, 
          centerY + star.y, 
          star.size * (isDarkTheme ? 2 : 3)
        );
        
        glow.addColorStop(0, star.color.replace(/[^,]+\)/, `${starOpacity})`));
        glow.addColorStop(1, star.color.replace(/[^,]+\)/, '0)'));
        
        ctx.fillStyle = glow;
        ctx.beginPath();
        ctx.arc(
          centerX + star.x, 
          centerY + star.y, 
          star.size * (isDarkTheme ? 2 : 3), 
          0, 
          Math.PI * 2
        );
        ctx.fill();
        
        // Draw star core
        ctx.fillStyle = star.color.replace(/[^,]+\)/, `${starOpacity})`);
        ctx.beginPath();
        ctx.arc(
          centerX + star.x, 
          centerY + star.y, 
          star.size, 
          0, 
          Math.PI * 2
        );
        ctx.fill();
      }
    }
    
    // Animation loop
    function animate() {
      // For smoother performance
      if (!document.hidden) {
        // Optimize performance on mobile
        const isMobile = window.innerWidth < 640;
        if (isMobile) {
          // On mobile, only update when touching or recently touched
          if (isTouching || (mouseActive && Date.now() - mouseLastMoved < 1000)) {
            // Always update during active touch
            updateStars();
            drawGalaxy();
          } else {
            // When not touching, update less frequently
            if (Math.random() < 0.4) { // Only update ~40% of frames
              updateStars();
              drawGalaxy();
            }
          }
        } else {
          updateStars();
          drawGalaxy();
        }
      }
      
      // Always request the next frame immediately
      animationFrameId = window.requestAnimationFrame(animate);
    }
    
    // Animation frame ID to keep track of requestAnimationFrame
    let animationFrameId = null;
    
    // Ensure animation continues running
    function ensureAnimationRunning() {
      // Make sure animation is running
      if (!animationFrameId) {
        animate();
      }
    }
    
    // Variables to track mouse state
    let mouseJustStopped = false;
    
    // Window resize handler
    window.addEventListener('resize', function() {
      init();
    });
    
    // Track mouse position for star interaction
    let mouseX = -1000;
    let mouseY = -1000;
    let mouseActive = false;
    let mouseLastMoved = 0;
    let mouseMoving = false;
    let mouseMoveTimeout = null;
    
    // Variables to track mouse/touch movement for cursor rotation
    let prevMouseX = 0;
    let prevMouseY = 0;
    let lastValidDx = 0;
    let lastValidDy = 0;
    let rocketAngle = 0;
    let touchStartX = 0;
    let touchStartY = 0;
    let isTouching = false;
    let touchTimeout = null;
    
    // Handle touch events for mobile
    document.addEventListener('touchstart', function(e) {
      if (!cursor) return;
      
      // Reset transition to initial state for new touch
      cursor.style.transition = "transform 0.8s cubic-bezier(0.22, 1, 0.36, 1), opacity 0.3s, text-shadow 0.3s";
      
      const touch = e.touches[0];
      touchStartX = touch.clientX;
      touchStartY = touch.clientY;
      isTouching = true;
      
      // Reset rocket and tracking variables
      rocketX = touch.clientX;
      rocketY = touch.clientY;
      lastTouchX = touch.clientX;
      lastTouchY = touch.clientY;
      touchVelocityX = 0;
      touchVelocityY = 0;
      
      // Position cursor at touch point initially but slightly above
      cursor.style.left = `${touch.clientX}px`;
      cursor.style.top = `${touch.clientY - 30}px`; // Start slightly above touch point
      cursor.style.opacity = '0.3'; // Start semi-transparent
      
      // Float down to touch point with animation
      setTimeout(() => {
        cursor.style.opacity = '1';
        cursor.style.top = `${touch.clientY}px`;
        // Reset the transform to avoid conflict with previous transitions
        cursor.style.transform = `translate(-50%, -50%) rotate(${Math.random() > 0.5 ? 30 : -30}deg)`;
      }, 50);
      
      // Calculate canvas-relative touch position for star effects
      const rect = canvas.getBoundingClientRect();
      mouseX = touch.clientX - rect.left;
      mouseY = touch.clientY - rect.top;
      mouseActive = true;
      mouseMoving = true;
      mouseLastMoved = Date.now();
      
      // Clear any existing timeout
      clearTimeout(touchTimeout);
      
      // Ensure animation is running during touch interaction
      ensureAnimationRunning();
    });
    
    // Variables for touch tracking
    let rocketX = 0;
    let rocketY = 0;
    let lastTouchX = 0;
    let lastTouchY = 0;
    let touchVelocityX = 0;
    let touchVelocityY = 0;
    
    document.addEventListener('touchmove', function(e) {
      if (!cursor || !isTouching) return;
      
      const touch = e.touches[0];
      
      // Update last touch position for tracking
      if (lastTouchX === 0) {
        lastTouchX = touch.clientX;
        lastTouchY = touch.clientY;
        rocketX = touch.clientX;
        rocketY = touch.clientY;
      }
      
      // Calculate movement direction and speed
      const dx = touch.clientX - touchStartX;
      const dy = touch.clientY - touchStartY;
      const distance = Math.sqrt(dx*dx + dy*dy);
      
      // Calculate touch velocity for trailing effect
      touchVelocityX = (touch.clientX - lastTouchX) * 0.2;
      touchVelocityY = (touch.clientY - lastTouchY) * 0.2;
      
      // Update last touch position
      lastTouchX = touch.clientX;
      lastTouchY = touch.clientY;
      
      // Smooth rocket position - follows touch with lag
      rocketX = rocketX * 0.8 + touch.clientX * 0.2;
      rocketY = rocketY * 0.8 + touch.clientY * 0.2;
      
      if (distance > 5) {
        // Store last valid movement direction
        lastValidDx = dx;
        lastValidDy = dy;
        
        // Calculate angle based on touch velocity for smoother rotation
        const moveAngle = Math.atan2(touchVelocityY, touchVelocityX);
        const targetAngle = moveAngle * (180 / Math.PI) + 90;
        
        // Smooth angle changes
        rocketAngle = rocketAngle * 0.85 + targetAngle * 0.15;
        
        // Calculate trailing position - rocket follows behind touch point with velocity influence
        let trailX = rocketX + touchVelocityX * 2;
        let trailY = rocketY + touchVelocityY * 2;
        
        // Apply rocket position and rotation with smooth animation
        cursor.style.left = `${trailX}px`;
        cursor.style.top = `${trailY}px`;
        cursor.style.transform = `translate(-50%, -50%) rotate(${rocketAngle}deg)`;
        
        // Calculate speed for glow effect - based on actual touch movement speed
        const moveSpeed = Math.sqrt(touchVelocityX*touchVelocityX + touchVelocityY*touchVelocityY);
        const speedFactor = Math.min(1, moveSpeed / 5);
        
        // Adjust glow based on speed
        const glowIntensity = 8 + speedFactor * 15;
        cursor.style.textShadow = `0 0 ${glowIntensity}px rgba(80, 180, 255, 0.8), 
                                  0 0 ${glowIntensity * 1.5}px rgba(120, 210, 255, 0.5)`;
        
        // Add size boost for faster movements - more subtle
        cursor.style.fontSize = `${Math.round(24 + speedFactor * 6)}px`;
        
        // Update canvas-relative position for star effects
        const rect = canvas.getBoundingClientRect();
        mouseX = touch.clientX - rect.left;
        mouseY = touch.clientY - rect.top;
        mouseLastMoved = Date.now();
      }
    });
    
    document.addEventListener('touchend', function() {
      if (!cursor) return;
      isTouching = false;
      
      // Continue moving in the last direction with momentum
      const continueMomentum = function() {
        if (!isTouching && touchVelocityX !== 0 && touchVelocityY !== 0) {
          // Get current position
          const currentX = parseFloat(cursor.style.left) || rocketX;
          const currentY = parseFloat(cursor.style.top) || rocketY;
          
          // Gradually reduce velocity (drag)
          touchVelocityX *= 0.95;
          touchVelocityY *= 0.95;
          
          // Update position with momentum
          const newX = currentX + touchVelocityX;
          const newY = currentY + touchVelocityY;
          
          // Update cursor position
          cursor.style.left = `${newX}px`;
          cursor.style.top = `${newY}px`;
          
          // Continue momentum until velocity becomes very small
          if (Math.abs(touchVelocityX) > 0.1 || Math.abs(touchVelocityY) > 0.1) {
            requestAnimationFrame(continueMomentum);
          } else {
            // When momentum stops, fade out rocket
            fadeOutRocket();
          }
        }
      };
      
      // Start momentum effect
      requestAnimationFrame(continueMomentum);
      
      // Function to fade out rocket after momentum ends
      const fadeOutRocket = function() {
        // Keep rocket visible for a short time after touch
        touchTimeout = setTimeout(function() {
          // Add a fly-away effect when touch ends
          if (lastValidDx !== 0 || lastValidDy !== 0) {
            const angle = Math.atan2(lastValidDy, lastValidDx);
            const currentX = parseFloat(cursor.style.left) || rocketX;
            const currentY = parseFloat(cursor.style.top) || rocketY;
            const flyAwayX = currentX + Math.cos(angle) * 200;
            const flyAwayY = currentY + Math.sin(angle) * 200;
            
            // Apply slow fade-out with transition
            cursor.style.transition = "transform 1.2s ease-out, opacity 0.8s ease-out";
            cursor.style.left = `${flyAwayX}px`;
            cursor.style.top = `${flyAwayY}px`;
            cursor.style.opacity = '0';
            
            // Trigger gravitational pull for stars
            mouseJustStopped = true;
            mouseMoving = false;
            
            // Reset touch state variables
            lastTouchX = 0;
            lastTouchY = 0;
            touchVelocityX = 0;
            touchVelocityY = 0;
            
            // Reset mouse position to remove influence after animation completes
            setTimeout(() => {
              mouseX = -1000;
              mouseY = -1000;
              mouseActive = false;
            }, 800);
          }
        }, 100);
      };
    });
    
    // Mouse move for cursor effect and star interaction
    document.addEventListener('mousemove', function(e) {
      // Update custom cursor position with rocket rotation
      if (cursor) {
        cursor.style.left = `${e.clientX}px`;
        cursor.style.top = `${e.clientY}px`;
        cursor.style.opacity = '1';
        
        // Calculate movement direction and speed
        const now = Date.now();
        const moveTime = now - mouseLastMoved;
        
        if (moveTime > 0 && mouseLastMoved !== 0) {
          const dx = e.clientX - prevMouseX;
          const dy = e.clientY - prevMouseY;
          const distance = Math.sqrt(dx*dx + dy*dy);
          const speed = distance / moveTime * 10;
          
          // Only update angle if there's significant movement
          if (distance > 2) {
            // Store the movement vector if it's valid
            lastValidDx = dx;
            lastValidDy = dy;
          }
          
          // Always calculate angle using the last valid movement
          // This allows the rocket to maintain its direction even when the mouse slows down
          if (lastValidDx !== 0 || lastValidDy !== 0) {
            // Calculate angle in the direction of travel
            const angle = Math.atan2(lastValidDy, lastValidDx);
            
            // Convert to degrees
            // The ðŸš€ emoji points up by default, which is -90 degrees in our system
            // So we add 90 degrees to make it point in the direction of movement
            rocketAngle = angle * (180 / Math.PI) + 90;
            
            // Apply rocket rotation - note we rotate in the opposite direction (negative angle)
            // This makes the rocket nose (top of the emoji) point in the direction of movement
            cursor.style.transform = `translate(-50%, -50%) rotate(${rocketAngle}deg)`;
          }
          
          // Adjust rocket glow based on speed
          const glowIntensity = Math.min(20, 10 + speed * 0.5);
          const glowColor = mouseMoving ? 
            `rgba(80, 180, 255, ${Math.min(0.9, 0.5 + speed * 0.04)})` : 
            'rgba(100, 200, 255, 0.5)';
          
          // Add rocket trail glow effect
          cursor.style.textShadow = `0 0 ${glowIntensity}px ${glowColor}, 
                                    0 0 ${glowIntensity * 1.5}px rgba(120, 210, 255, 0.4)`;
          
          // Add rocket thrust animation at high speeds
          if (speed > 8) {
            cursor.style.animation = 'rocket-thrust 0.8s infinite alternate';
          } else {
            cursor.style.animation = 'none';
            // Just add size boost at lower speeds
            const sizeBoost = Math.min(1.5, 1 + speed * 0.01);
            cursor.style.fontSize = `${Math.round(32 * sizeBoost)}px`;
          }
        }
        
        // Update previous position for next movement calculation
        prevMouseX = e.clientX;
        prevMouseY = e.clientY;
        mouseLastMoved = now;
      }
      
      // Calculate canvas-relative mouse position
      const rect = canvas.getBoundingClientRect();
      mouseX = e.clientX - rect.left;
      mouseY = e.clientY - rect.top;
      mouseActive = true;
      
      // Flag when mouse is actively moving
      mouseMoving = true;
      
      // Reset flag after mouse stops moving to trigger gravity return
      clearTimeout(mouseMoveTimeout);
      mouseMoveTimeout = setTimeout(function() {
        // When mouse stops, set flag to trigger gravitational pull
        mouseJustStopped = true;
        mouseMoving = false;
        // Mouse stopped - activate gravity pull effect
      }, 150);
      
      // Ensure animation is running during mouse interaction
      ensureAnimationRunning();
    });
    
    // Mouse leave - reset interaction and trigger gravity return
    document.addEventListener('mouseleave', function() {
      // Don't hide the cursor on mobile - only hide it on desktop
      if (cursor && window.innerWidth >= 640) {
        // Add a bit of a fly-away effect when leaving
        cursor.style.transition = "opacity 0.5s, transform 0.5s";
        
        // Make the rocket "fly away" in the last direction it was moving
        // Use the last valid movement direction
        const flyAngle = lastValidDx !== 0 || lastValidDy !== 0 
          ? Math.atan2(lastValidDy, lastValidDx) * (180 / Math.PI) + 90
          : rocketAngle;
          
        // Apply the rocket rotation and fly-away effect
        cursor.style.transform = `translate(-50%, -50%) rotate(${flyAngle}deg) translate(0, -100px) scale(0.5)`;
        
        // Fade out
        cursor.style.opacity = '0';
        
        // Reset transition after the animation
        setTimeout(() => {
          cursor.style.transition = "transform 0.3s cubic-bezier(0.34, 1.56, 0.64, 1), opacity 0.2s, text-shadow 0.2s";
        }, 500);
      }
      
      // Move mouse off-canvas to remove influence
      mouseX = -1000;
      mouseY = -1000;
      mouseActive = false;
      mouseMoving = false;
      
      // Set flag to trigger gravitational pull
      mouseJustStopped = true;
    });
    
    // Handle mouse enter for consistency
    document.addEventListener('mouseenter', function() {
      mouseActive = true;
    });
    
    // Theme change detection
    const observer = new MutationObserver(function(mutations) {
      mutations.forEach(function(mutation) {
        if (mutation.attributeName === 'data-theme') {
          isDarkTheme = document.documentElement.getAttribute('data-theme') === 'dark';
        }
      });
    });
    
    observer.observe(document.documentElement, {
      attributes: true,
      attributeFilter: ['data-theme']
    });
    
    // Initialize and start animation
    init();
    animate();
  });
</script>